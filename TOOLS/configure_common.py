import atexit
import os
import shutil
import subprocess
import sys
import tempfile

# ...the fuck?
NoneType = type(None)
function = type(lambda: 0)

class _G:
    help_mode = False   # set if --help is specified on the command line

    log_file = None     # opened log file

    temp_path = None    # set to a private, writable temporary directory

    cflags = []
    ldflags = []

    config_h = ""       # new contents of config.h (written at the end)

    sources = []

    state_stack = []

    feature_opts = {}   # keyed by option name, values are:
                        #   "yes": force enable, like --enable-<feature>
                        #   "no": force disable, like: --disable-<feature>
                        #   "auto": force auto detection, like --with-<feature>=auto
                        #   "default": default (same as option not given)

    dep_enabled = {}    # keyed by dependency identifier; value is a bool


# Convert a string to a C string literal. Adds the required "".
def _c_string(s):
    s = s.replace("\\", "\\\\")
    s = s.replace("\"", "\\\"")
    return "\"%s\"" % s

def die(msg):
    sys.stderr.write("Fatal error: %s\n" % msg)
    sys.stderr.write("Not updating build files.\n")
    _G.log_file.write("--- Stopping due to error: %s\n" % msg)
    sys.exit(1)

# To be called before any user checks are performed.
def begin():
    for arg in sys.argv[1:]:
        if arg.startswith("-"):
            name = arg[1:]
            if name.startswith("-"):
                name = name[1:]
            opt = name.split("=", 1)
            name = opt[0]
            val = opt[1] if len(opt) > 1 else ""
            def noval():
                if val:
                    die("Option --%s does not take a value." % name)
            if name == "help":
                noval()
                _G.help_mode = True
                continue
            elif name.startswith("enable-"):
                noval()
                _G.feature_opts[name[7:]] = "yes"
                continue
            elif name.startswith("disable-"):
                noval()
                _G.feature_opts[name[8:]] = "no"
                continue
            elif name.startswith("with-"):
                if val not in ["yes", "no", "auto", "default"]:
                    die("Option --%s requires 'yes', 'no', 'auto', or 'default'."
                        % name)
                _G.feature_opts[name[5:]] = val
                continue
        die("Unknown option: %s" % arg)

    if _G.help_mode:
        return

    _G.temp_path = tempfile.mkdtemp(prefix = "mpv-configure")
    def _cleanup():
        shutil.rmtree(_G.temp_path)
    atexit.register(_cleanup)

    _G.build_dir = "build"
    try:
        os.makedirs(_G.build_dir)
    except OSError:
        # What we want are "mkdir -p" semantics regarding existing dirs.
        # os.makedirs (as well as os.mkdir) do exactly what you don't want: they
        # raise an exception is the dir /leaf dir already exists. So just ignore
        # all errors.
        pass
    _G.log_file = open(os.path.join(_G.build_dir, "config.log"), "w")

    _G.config_h += "// Generated by configure.\n" + \
                   "#pragma once\n\n"


class Struct(object):
    def __init__(self, **kwargs):
        for name, value in kwargs.items():
            setattr(self, name, value)

    def __repr__(self):
        class_members = dir(self.__class__)
        members = dir(self)
        items = []
        for name in members:
            if name in class_members:
                continue
            items.append("%s=%s" % (name, getattr(self, name)))
        return "<Struct(%s)>" % (", ".join(items))

# Check whether the first argument is the same type of any in the following
# arguments. This _always_ returns val, but throws an exception if type checking
# fails.
# This is not very pythonic, but I'm trying to prevent bugs, so bugger off.
def typecheck(val, *types):
    vt = type(val)
    for t in types:
        if vt == t:
            return val
    raise Exception("Value '%s' of type %s not any of %s" % (val, type(val), types))

# If val is None, return []
# If val is a list, return val.
# Otherwise, return [val]
def normalize_list_arg(val):
    if val is None:
        return []
    if type(val) == list:
        return val
    return [val]

def push_build_flags():
    _G.state_stack.append(Struct(
        cflags = _G.cflags[:],
        ldflags = _G.ldflags[:],
    ))

def pop_build_flags_discard():
    top = _G.state_stack[-1]
    _G.state_stack = _G.state_stack[:-1]

    _G.cflags = top.cflags
    _G.ldflags = top.ldflags

def pop_build_flags_merge():
    top = _G.state_stack[-1]
    _G.state_stack = _G.state_stack[:-1]

# A check is a check, dependency, or anything else that adds source files,
# preprocessor symbols, libraries, include paths, or simply serves as
# dependency check for other checks.
# Always call this function with named arguments.
# Arguments:
#   name: String or None. Symbolic name of the check. The name can be used as
#         dependency identifier by other checks. This is the first argument, and
#         usually passed directly, instead of as named argument.
#         If this starts with a "-" flag, options with names derived from this
#         are generated:
#           --enable-$option
#           --disable-$option
#           --with-$option=<yes|no|auto|default>
#         Where "$option" is the name without flag characters, and occurrences
#         of "_" are replaced with "-".
#         If this ends with a "*" flag, the result of this check is emitted as
#         preprocessor symbol to config.h. It will have the name "HAVE_$DEF",
#         and will be either set to 0 (check failed) or 1 (check succeeded),
#         and $DEF is the name without flag characters and all uppercase.
#   desc: String or None. If specified, "Checking for <desc>..." is printed
#         while running configure. If not specified, desc is auto-generated from
#         the name.
#   default: Boolean or None. If True or None, the check is soft-enabled (that
#            means it can still be disabled by options, dependency checks, or
#            the check function). If False, the check is disabled by default,
#            but can be enabled by an option.
#   deps, deps_any, deps_neg: String, array of strings, or None. If a check is
#       enabled by default/command line options, these checks are performed in
#       the following order: deps_neg, deps_any, deps
#       deps requires all dependencies in the list to be enabled.
#       deps_any requires 1 or more dependencies to be enabled.
#       deps_neg requires that all dependencies are disabled.
#   fn: Function or None. The function is run after dependency checks. If it
#       returns True, the check is enabled, if it's False, it will be disabled.
#       Typically, your function for example check for the existence of
#       libraries, and add them to the final list of CFLAGS/LDFLAGS.
#       None behaves like "lambda: True".
#       Note that this needs to be a function. If not, it'd be run before the
#       check() function is even called. That would mean the function runs even
#       if the check was disabled, and could add unneeded things to CFLAGS.
#   sources: String, Array of Strings, or None.
#            If the check is enabled, add these sources to the build.
#   required: String or None. If this is a string, the check is required, and
#             if it's not enabled, the string is printed as error message.
def check(name = None, option = None, desc = None, deps = None, deps_any = None,
          deps_neg = None, sources = None, fn = None, required = None,
          default = None):

    deps = normalize_list_arg(deps)
    deps_any = normalize_list_arg(deps_any)
    deps_neg = normalize_list_arg(deps_neg)
    sources = normalize_list_arg(sources)

    typecheck(name, str, NoneType)
    typecheck(option, str, NoneType)
    typecheck(desc, str, NoneType)
    typecheck(deps, NoneType, list)
    typecheck(deps_any, NoneType, list)
    typecheck(deps_neg, NoneType, list)
    typecheck(sources, NoneType, list)
    typecheck(fn, NoneType, function)
    typecheck(required, str, NoneType)
    typecheck(default, bool, NoneType)

    option_name = None
    define_name = None
    if name is not None:
        opt_flag = name.startswith("-")
        if opt_flag:
            name = name[1:]
        def_flag = name.endswith("*")
        if def_flag:
            name = name[:-1]
        if opt_flag:
            option_name = name.replace("_", "-")
        if def_flag:
            define_name = "HAVE_" + name.replace("-", "_").upper()

    if desc is None and name is not None:
        desc = name

    if _G.help_mode:
        if not option_name:
            return

        defaction = "enable"
        if required is not None:
            # If they are required, but also have option set, these are just
            # "strongly required" options.
            defaction = "enable"
        elif default == False:
            defaction = "disable"
        elif deps or deps_any or deps_neg or fn:
            defaction = "autodetect"
        act = "enable" if defaction == "disable" else "disable"
        opt = "--%s-%s" % (act, option_name)
        print("  %-30s %s %s [%s]" % (opt, act, desc, defaction))
        return

    _G.log_file.write("--- Test: %s\n" % (name if name else "(unnnamed)"))

    if desc:
        sys.stdout.write("Checking for %s..." % desc)
    outcome = "yes"

    force_opt = required is not None
    use_dep = True if default is None else default

    # Option handling.
    if option_name:
        # (The option gets removed, so we can determine whether all options were
        # applied in the end.)
        val = _G.feature_opts.pop(option_name, "default")
        if val == "yes":
            use_dep = True
            force_opt = True
        elif val == "no":
            use_dep = False
            force_opt = False
        elif val == "auto":
            use_dep = True
        elif val == "default":
            pass
        else:
            assert False

    if not use_dep:
        outcome = "disabled"

    # Dependency resolution.
    if use_dep:
        for d in deps_neg:
            if dep_enabled(d):
                use_dep = False
                outcome = "conflicts with %s" % d
                break
    if use_dep:
        any_found = False
        for d in deps_any:
            if dep_enabled(d):
                any_found = True
                break
        if len(deps_any) > 0 and not any_found:
            use_dep = False
            outcome = "not any of %s found" % (", ".join(deps_any))
    if use_dep:
        for d in deps:
            if not dep_enabled(d):
                use_dep = False
                outcome = "%s not found" % d
                break

    # Running actual checks.
    if use_dep and fn:
        push_build_flags()
        if fn():
            pop_build_flags_merge()
        else:
            pop_build_flags_discard()
            use_dep = False
            outcome = "no"

    # Outcome reporting and terminating if dependency not found.
    if name:
        _G.dep_enabled[name] = use_dep
    if define_name:
        add_config_h_define(define_name, 1 if use_dep else 0)
    if use_dep:
        _G.sources += sources
    if desc:
        sys.stdout.write(" %s\n" % outcome)
    _G.log_file.write("--- Outcome: %s (%s=%d)\n" %
                      (outcome, name if name else "(unnnamed)", use_dep))

    if required is not None and not use_dep:
        print("Warning: %s" % required)

    if force_opt and not use_dep:
        die("This feature is required.")


# Runs the process like with execv() (just that args[0] is used for both command
# and first arg. passed to the process).
# Returns the process stdout output on success, or None on non-0 exit status.
# In particular, this logs the command and its output/exit status to the log
# file.
def _run_process(args):
    p = subprocess.Popen(args, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    (p_out, p_err) = p.communicate()
    # We don't really want this. But Python 3 in particular makes it too much of
    # a PITA (think power drill in anus) to consistently use byte strings, so
    # we need to use "unicode" strings. Yes, a bad program could just blow up
    # our butt here by outputting invalid UTF-8.
    p_out = p_out.decode("utf-8")
    p_err = p_err.decode("utf-8")
    status = p.wait()
    _G.log_file.write("--- Command: %s\n" % " ".join(args))
    if p_out:
        _G.log_file.write("--- stdout:\n%s" % p_out)
    if p_err:
        _G.log_file.write("--- stderr:\n%s" % p_err)
    _G.log_file.write("--- Exit status: %s\n" % status)
    return p_out if status == 0 else None

# Run the C compiler, possibly including linking. Return whether the compiler
# exited with success status (0 exit code) as boolean. What exactly it does
# depends on the arguments. Generally, it constructs a source file and tries
# to compile it. With no arguments, it compiles, but doesn't link, a source
# file that contains a dummy main function.
# Note: these tests are cumulative.
# Arguments:
#   include: String, array of strings, or None. For each string
#            "#include <$value>" is added to the top of the source file.
#   decl: String, array of strings, or None. Added to the top of the source
#         file, global scope, separated by newlines.
#   expr: String or None. Added to the body of the main function. Despite the
#         name, needs to be a full statement, needs to end with ";".
#   defined: String or None. Adds code that fails if "#ifdef $value" fails.
#   flags: String, array of strings, or None. Each string is added to the
#          compiler command line.
#          Also, if the test succeeds, all arguments are added to the CFLAGS
#          (if language==c) written to config.mak.
#   link: String, array of strings, or None. Each string is added to the
#         compiler command line, and the compiler is made to link (not passing
#         "-c").
#         A value of [] triggers linking without further libraries.
#         A value of None disables the linking step.
#         Also, if the test succeeds, all link strings are added to the LDFLAGS
#         written to config.mak.
#   language: "c" for C, "m" for Objective-C.
def check_cc(include = None, decl = None, expr = None, defined = None,
             flags = None, link = None, language = "c"):
    assert language in ["c", "m"]

    use_linking = link is not None

    contents = ""
    for inc in normalize_list_arg(include):
        contents += "#include <%s>\n" % inc
    for dec in normalize_list_arg(decl):
        contents += "%s\n" % dec
    for define in normalize_list_arg(defined):
        contents += ("#ifndef %s\n" % define) + \
                    "#error failed\n" + \
                    "#endif\n"
    if expr or use_linking:
        contents += "int main(int argc, char **argv) {\n";
        if expr:
            contents += expr + "\n"
        contents += "return 0; }\n"
    source = os.path.join(_G.temp_path, "test." + language)
    _G.log_file.write("--- Test file %s:\n%s" % (source, contents))
    with open(source, "w") as f:
        f.write(contents)

    flags = normalize_list_arg(flags)
    link = normalize_list_arg(link)

    outfile = os.path.join(_G.temp_path, "test")
    args = ["cc", source]
    args += _G.cflags + flags
    if use_linking:
        args += _G.ldflags + link
        args += ["-o%s" % outfile]
    else:
        args += ["-c", "-o%s.o" % outfile]
    if _run_process(args) is None:
        return False

    _G.cflags += flags
    _G.ldflags += link
    return True

# Run pkg-config with function arguments passed as command arguments. Typically,
# you specify pkg-config version expressions, like "libass >= 0.14". Returns
# success as boolean.
# If this succeeds, the --cflags and --libs are added to CFLAGS and LDFLAGS.
def check_pkg_config(*args):
    args = list(args)
    pkg_config_cmd = ["pkg-config"]

    cflags = _run_process(pkg_config_cmd + ["--cflags"] + args)
    if cflags is None:
        return False
    ldflags = _run_process(pkg_config_cmd + ["--libs"] + args)
    if ldflags is None:
        return False

    _G.cflags += cflags.split()
    _G.ldflags += ldflags.split()
    return True

# Return whether all passed dependency identifiers are fulfilled.
def dep_enabled(*deps):
    for d in deps:
        val = _G.dep_enabled.get(d, None)
        assert val is not None, "Internal error: unknown dependency %s" % d
        if not val:
            return False
    return True

# Add all of the passed strings to CFLAGS.
def add_cflags(*fl):
    _G.cflags += list(fl)

# Add a preprocessor symbol of the given name to config.h.
# If val is a string, it's quoted as string literal.
# If val is None, it's defined without value.
def add_config_h_define(name, val):
    if type(val) == type("") or type(val) == type(b""):
        val = _c_string(val)
    if val is None:
        val = ""
    _G.config_h += "#define %s %s\n" % (name, val)

# Add these source files to the build.
def add_sources(*sources):
    _G.sources += list(sources)

# To be called at the end of user checks.
def finish():
    is_fatal = False
    for key, val in _G.feature_opts.items():
        print("Unknown feature set on command line: %s" % key)
        if val == "yes":
            is_fatal = True
    if is_fatal:
        die("Unknown feature was force-enabled.")

    _G.config_h += "\n"
    add_config_h_define("CONFIGURATION", " ".join(sys.argv))
    add_config_h_define("MPV_CONFDIR", "TODO")
    enabled_features = [x[0] for x in filter(lambda x: x[1], _G.dep_enabled.items())]
    add_config_h_define("FULLCONFIG", " ".join(sorted(enabled_features)))

    with open(os.path.join(_G.build_dir, "config.h"), "w") as f:
        f.write(_G.config_h)

    config_mak = "# Generated by configure.\n\n"
    config_mak += "CFLAGS = %s\n" % " ".join(_G.cflags)
    config_mak += "\n"
    config_mak += "LDFLAGS = %s\n" % " ".join(_G.ldflags)
    config_mak += "\n"

    config_mak += "SOURCES = \\\n"
    for s in sorted(list(set(_G.sources))):
        config_mak += "   %s \\\n" % s
    config_mak += "\n"

    with open(os.path.join(_G.build_dir, "config.mak"), "w") as f:
        f.write(config_mak)

    _G.log_file.write("--- Finishing successfully.\n")
    print("Done. You can run 'make' now.")

# Return whether to actually run configure tests, and whether results of those
# tests are available.
def is_running():
    return not _G.help_mode

# Each argument is an array or tuple, with the first element giving the
# dependency identifier, or "_" to match always fulfilled. The elements after
# this are added as source files if the dependency matches. This stops after
# the first matching argument.
def pick_first_matching_dep(*deps):
    winner = None
    for e in  deps:
        if (e[0] == "_" or dep_enabled(e[0])) and (winner is not None):
            # (the odd indirection though winner is so that all dependency
            #  identifiers are checked for existence)
            winner = e[1:]
    if winner is not None:
        add_sources(*winner)
